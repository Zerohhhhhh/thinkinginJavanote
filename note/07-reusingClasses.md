# 第7章 复用类

复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语宫，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。

此方法的窍门在于使用类而不破坏现有程序代码。读者将会在本章中看到两种达到这一目的的方法。

第一种方法非常直观:只需在新的类中产生现有类的对象。由于新的类是由现有类的对象所组成，所以**这种方法称为组合**。

第二种方法则更细致一些，它按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种神奇的方式称为**继承**。**继承是面向对象程序设计的基石之一**。

就组合和继承而言，其语法和行为大多是相似的。由于它们是利用现有类型生成新类型，所以这样做极富意义。

## 组合语法

编译器并不是简单地为每一个引用都创建默认对象,这一点是很有意义的,因为若真要那样做的话, 就会在许多情况下增加不必要的负担。 如果想初始化这些引用, 可以在代码中的下列位置进行:

1. 在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。

2. 在类的构造器中。

3. 就在正要使用这些对象之前,这种方式称为惰性初始化。在生成对象不值得及不必毎次都生成对象的情况下，这种方式可以减少额外的负担。

4. 使用实例初始化。

## 继承语法

当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从java的标准根类Object进行继承。

为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public（稍后将会学到protected成员也可以借助导出类来访问）。

子类是由关键字extends从父类导出的，所以子类可以在其接口中自动获得父类的方法，尽管不能看到父类的方法在子类中的显式定义。因此，可以将继承视作是对类的复用。

java用super关键字表示超类（即父类）的意思，当前类就是从超类继承来的。为此，表达式super.method()将调用基类版本的method()方法。

## 初始化基类

由于现在涉及基类和导出类这两个类，而不是只有一个类，所以要试着想像导出类所产生的结果对象，会有点困感。从外部来看，它就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你用基类直接创建的对象是一样的。二者区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。Java会自动在导出类的构造器中插人对基类构造器的调用。即使不为子类创建构造器，编译器也会为你合成一个默认的构造器，该构造器将调用基类的构造器。

### 带参数的构造器

如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地编写调用基类构造器的语句，并且配以适当的参数列表。即：

1.  如果想调用带参数的基类构造器只能用super调用；

2. 如果基类只有带参数构造器，则导出类必须显式编写构造器并使用super显式调用基类带参数构造器。

3.  如果基类存在带参数构造器，但导出类不打算调用带参数的基类构造器。则基类中必须显式编写无参数构造器，导出类中可以用关键字super显式地编写调用基类无参数构造器或省略不写。



## final关键字

### final类

当将某个类的整体定义为final是，就表明这个类无法被继承，即这个类不会有子类。

final类的域可以根据自己的意愿选择为是或不是final。不论类是否被定义为final，相同的规则都使用于定义为final的域。然而，final类中所有的方法都隐式指定为是final的（即使给final类中的方法添加final修饰词，也不会增添任何意义）。

## 初始化及类的加载

类在运行的时候，发生的第一件事就是试图访问main()，于是加载器开始启动并找出该类的编译代码。在对它进行加载的过程中，如果该类有基类（即父类），在会先停下该类的加载转而加载该类的基类，以此类推，直到没有基类为止。加载根基类过程中，static初始化会被执行，加载结束后，然后是下一个导出类，以此类推。必要的类都被加载完毕后（此时static初始化完毕），对象就可以被创建了。

首先，对象中所有的基本类型都会被设为默认值，对象引用被设为null。然后，基类的构造器会被调用。在基类构造器完成之后，实例变量按其次序被初始化。最后构造器的其余部分被执行。

