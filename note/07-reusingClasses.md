# 第7章 复用类

复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语宫，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。

此方法的窍门在于使用类而不破坏现有程序代码。读者将会在本章中看到两种达到这一目的的方法。

第一种方法非常直观:只需在新的类中产生现有类的对象。由于新的类是由现有类的对象所组成，所以**这种方法称为组合**。

第二种方法则更细致一些，它按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种神奇的方式称为**继承**。**继承是面向对象程序设计的基石之一**。

就组合和继承而言，其语法和行为大多是相似的。由于它们是利用现有类型生成新类型，所以这样做极富意义。

## 组合语法

编译器并不是简单地为每一个引用都创建默认对象,这一点是很有意义的,因为若真要那样做的话, 就会在许多情况下增加不必要的负担。 如果想初始化这些引用, 可以在代码中的下列位置进行:

1. 在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。

2. 在类的构造器中。

3. 就在正要使用这些对象之前,这种方式称为惰性初始化。在生成对象不值得及不必毎次都生成对象的情况下，这种方式可以减少额外的负担。

4. 使用实例初始化。

## 继承语法

当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从java的标准根类Object进行继承。

为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public（稍后将会学到protected成员也可以借助导出类来访问）。

子类是由关键字extends从父类导出的，所以子类可以在其接口中自动获得父类的方法，尽管不能看到父类的方法在子类中的显式定义。因此，可以将继承视作是对类的复用。

java用super关键字表示超类（即父类）的意思，当前类就是从超类继承来的。为此，表达式super.method()将调用基类版本的method()方法。

## 初始化基类

由于现在涉及基类和导出类这两个类，而不是只有一个类，所以要试着想像导出类所产生的结果对象，会有点困感。从外部来看，它就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你用基类直接创建的对象是一样的。二者区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。Java会自动在导出类的构造器中插人对基类构造器的调用。即使不为子类创建构造器，编译器也会为你合成一个默认的构造器，该构造器将调用基类的构造器。

### 带参数的构造器

如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地编写调用基类构造器的语句，并且配以适当的参数列表。即：

1.  如果想调用带参数的基类构造器只能用super调用；
2.  如果基类只有带参数构造器，则导出类必须显式编写构造器并使用super显式调用基类带参数构造器。
3.  如果基类存在带参数构造器，但导出类不打算调用带参数的基类构造器。则基类中必须显式编写无参数构造器，导出类中可以用关键字super显式地编写调用基类无参数构造器或省略不写。

## 名称屏蔽

在C++中，如果基类拥有一个已被多次重载的方法名称，那么在其派生类中重新定义该方法名称，就会屏蔽其基类中的任何版本，这叫做名称屏蔽。但是在Java中，就种情况下，不会发生名称屏蔽，即无论在派生类还是在基类中对方法进行定义，重载机制都可以正常工作。

## 在组合与继承之间选择

**组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做。**读者或许想知道二者间的区别何在，以及怎样在二者之间做出选择。

组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形，即，在新类中嵌人某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌人对象的接口。为取得此效果，需要在新类中嵌入一个现有类的private对象。

在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。略微思考一下就会发现，用一个“交通工具”对象来构成一部“车子”是毫无意义的，因为“车子”并不包含“交通工具”，它仅是一种交通工具（is-a关系）、“is-a”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。

## protected关键字

在理想世界中，仅靠关键字private就已经足够了。但在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但仍然允许导出类的成员访问它们。

关键字protected就是起这个作用的。它指明“**就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说， 它却是可以访问的。**” (protected也提供了包内访问权限。）

**尽管可以创建protected域，但是最好的方式还是将域保持为private**；你应当一直保留“更改底层实现”的权利。然后通过protected方法来控制类的继承者的访问权限。

## 向上转型

“为新的类提供方法”并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类时现有类的一种类型”这句话加以概括。

由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。

**程序代码可以对基类和它所有导出类起作用，这种将导出类引用转换成基类引用的动作，称之为向上转型。**由于向上转型是从一个较专用类型向较通用类型转换，所以**总是很安全的**。也就是，导出类是基类的一个超集。它可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。在向上转型过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。

也可以执行**与向上转型相反的向下转型。**

在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装进一个类中，并使用该类的对象。也可以运用组合技术使用现有类来开发新的类；而继承技术其实不太常用。

## final关键字

根据上下文环境，java的关键字final的含义存在着细微的区别，但通常它是指“这是无法改变的”。不想做改变可能出于两种理由：设计或效率。

**可能使用到final的三种情况：数据、方法和类。**

## final数据



### final类

当将某个类的整体定义为final是，就表明这个类无法被继承，即这个类不会有子类。

final类的域可以根据自己的意愿选择为是或不是final。不论类是否被定义为final，相同的规则都使用于定义为final的域。然而，final类中所有的方法都隐式指定为是final的（即使给final类中的方法添加final修饰词，也不会增添任何意义）。

## 初始化及类的加载

类在运行的时候，发生的第一件事就是试图访问main()，于是加载器开始启动并找出该类的编译代码。在对它进行加载的过程中，如果该类有基类（即父类），在会先停下该类的加载转而加载该类的基类，以此类推，直到没有基类为止。加载基类过程中，static初始化会被执行，加载结束后，然后是下一个导出类，以此类推。必要的类都被加载完毕后（此时static初始化完毕），对象就可以被创建了。

首先，对象中所有的基本类型都会被设为默认值，对象引用被设为null。然后，基类的构造器会被调用。在基类构造器完成之后，实例变量按其次序被初始化。最后构造器的其余部分被执行。

