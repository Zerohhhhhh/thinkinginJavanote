# 第14章 类型信息

**运行时类型信息（RTTI）使得你可以在程序运行时发现和使用类型信息。**

它使你从只能在编译期执行面向类型的操作的禁锢中解脱了出来，并且可以使用某些非常强大的程序。对RTTI的需要，揭示了面向对象设计中许多有趣（并且复杂）的问题，同时也提出了如何组织程序的问题。

**Java在运行时识别对象和类的信息的**。主要有两种方式：一种是 “传统的” RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。

----

## RTTI（Runtime Type Identification）运行阶段类型识别

### 用途

为了确定基类指针实际指向的子类的具体类型。

### 工作原理

通过类型转换运算符回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。

### Java中

在Java中，**所有的类型转换都是在运行时进行正确性检查的**。这也是RTTI的**含义**：在运行时，识别一个对象的类型。

#### 丢失具体类型信息的问题

1. 多态中表现的类型转换是RTTI最基本的使用形式，但这种转换并不彻底。如数组容器实际上将所有元素当作Object持有，取用时再自动将结果转型回声明类型。而数组在填充（持有）对象时，具体类型可能是声明类型的子类，这样放到数组里就会向上转型为声明类型，持有的对象就丢失了具体类型。而取用时将由Object只转型回声明类型，并不是具体的子类类型，所以这种转型并不彻底。
2. 多态中表现了具体类型的行为，但那只是“多态机制”的事情，是由引用所指向的具体对象而决定的，并不等价于在运行时识别具体类型。 

  以上揭示了一个问题就是具体类型信息的丢失！有了问题，就要解决问题，这就是RTTI的需要，即在运行时确定对象的具体类型。

#### 证实具体类型信息的丢失

```java
abstract class Shape{
    void draw(){
        System.out.println(this + ".draw()");
    }
    abstract public String toString();  //要求子类需要实现 toString()
}

class Circle extends Shape{
    @Override
    public String toString() {
        return "Circle";
    }
    public void drawCircle(){}
}

class Square extends Shape{
    @Override
    public String toString() {
        return "Square";
    }
}

class Triangle extends Shape{
    @Override
    public String toString() {
        return "Triangle";
    }
}
public class Shapes {
    public static  void main(String[] args){
        List<Shape> shapeList = Arrays.asList(
                new Circle(), new Square(), new Triangle()  // 向上转型为 Shape，此处会丢失原来的具体类型信息！！对于数组而言，它们只是Shape类对象！
        );
        for(Shape shape : shapeList){
            shape.draw();   // 数组实际上将所有事物都当作Object持有，在取用时会自动将结果转型回声明类型即Shape。
        }
        //shapeList.get(0).drawCircle(); //这里会编译错误：在Shape类中找不到符号drawCircle()，证实了具体类型信息的丢失!!
    }
}

```

##  Class对象

要理解RTTI在Java中的工作原理， 首先必须知道类型信息在运行时是如何表示的。 这项工作是由称为Class对象的特殊对象完成的 ， 它包含了与类有关的信息。 事实上 ， Class对象就是用来创建类的所有的 “常规" 对象的。 Java使用Class对象来执行其RTTI, 即使你正在执行的是类似转型这样的操作。Class类还拥有大量的使用RTTI的其他方式。

类是程序的一部分 ， 每个类都有一个Class对象。 换言之，每当编写并且编译了一个新类，就会产生一个Class对象 （更恰当地说， 是被保存在一个同名的.class文件中 ）。为了生成这个类的对象，运行这个程序的Java虚拟机(JVM)将使用被称为“类加载器”的子系统。

类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM 实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需求（例如以某种特殊的方式加载类，以支持Web服务器应用，或者在网络中下载类) ,那么你有一种方式可以挂接额外的类加载器。

所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当作对类的静态成员的引用。

因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必需时才加载的。动态加载使能的行为，在诸如c++这样的静态加载语言中是很难或者根本不可能复制的。

### 类加载器的工作过程

1. 类加载器首先检查这个类的Class对象是否已经加载。

2. 如果尚未加载，默认的类加载器就会根据类名查找.class文件（例如，某个附加类加载器可能会在数据库中查找字节码）。

3. 在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码（这是Java 中用于安全防范目的的措施之一)。

4. 一旦某个类的Class对象被载人内存，它就被用来创建这个类的所有对象。

   下面的示范程序可以证明这一点：