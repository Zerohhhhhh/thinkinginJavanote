# 第8章 多态

多态是一项让程序员“将改变的事务与未变的事物分离开来”的重要技术。



***在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征***

1. **多态**通过分离做什么和怎么做，从另一角度将接口和实现分离出来。

2. **“封装”** 通过合并特征和行为来创建新的数据类型。

3. **“实现隐藏”** 则通过将细节“私有化”把接口和实现分离开来。

**多态的作用**则是消除类型之间的耦合关系。

## 再论向上转型

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。这种把对某个对象的引用视为对其基类型的引用的做法被称作为**向上转型**。

## 方法调用绑定

1. **绑定：将一个方法调用同一个方法主体关联起来被称作绑定。**
2. **前期绑定：若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现）。面向过程语言中默认的绑定方式（例如C语言）。**
3. **后期绑定：在运行时根据对象的类型进行绑定。也叫动态绑定或运行时绑定。**采用后期绑定的语言具有某种机制，程序运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器一直不知道对象的类型，但是方法调用机制能够找到正确的方法体，并加以调用。

***<u>java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。即程序员不必判定是否应该进行后期绑定，它会自动发生。</u>***

### 方法声明为final的更重要意义

将某个方法声明为final，除了防止其他人覆盖该方法，**更重要的是可以有效地“关闭”动态绑定，或者说，告诉编译器不需要对其进行动态绑定。**

编译器可以为final方法调用生成更有效的代码，但是这样对程序整体性能不会太大提高，因此不应该试图提高性能而使用final，而是出于程序设计来决定。

### 产生正确的行为

![08-Polymorphism01](https://github.com/Zerohhhhhh/thinkinginJavanote/blob/603e6033282df37cb829d0c8b9944463d32bff3a/images/08-Polymorphism01.jpg)



在“几何形状”这个例子中，有一个基类Shape，以及多个导出类——Circle、Square和Triangle等。

向上转型可以像下面这条语句：

```java
Shape s = new Circle();
```

创建一个Circle对象，并把得到的引用立即赋值给Shape。因为通过继承，Circle就是一种Shape。假如调用一个基类方法（该方法已在导出类中被覆盖）：

```java
s.draw();	
```

由于后期绑定（多态），因此上述语句还是正确调用Circle.draw()方法。

### 可扩展性

在一个设计良好的OOP程序中，大多数或者所有方法只与接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。

### 缺陷：“覆盖”私有方法

由于基类的private方法被自动认为是final方法，而且对导出类是屏蔽的。因此，在这种情况下，导出类中与基类private方法名相同的方法是一个全新的方法，即基类的private方法无法被重载。

只有非private方法才可以被覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行（假设我们期望覆盖基类的private方法）。

在导出类中，对于基类中的private方法，最好采用不同的名字。

### 缺陷：域与静态方法

1. 多态机制并不是对所有事物都发生的，只有普通方法调用可以是多态的。即如果直接访问某个域，这个访问就将在编译期进行解析。

```java
class Super{
    public int field = 0;
    public int getField(){
        return file;
    }
}

class Sub extends Super{
    public int field = 1;
    public int getField(){
        return filed;
    }
}

/*
	调用即结果
	Super sup = new Sub();
	sup.field;  // 0  (域无法发生多态，即如果发生则结果为1)
	sup.getField(); //	1 （多态机制）
*/

```

Super.field和Sub.field分配了不同的存储空间。因此，Sub实际上包含两个称为field的域：它自己的和它从Super处得到的。如果想在Sub得到Super.field，必须显式地指明super.field。

2. 如果某个方法是静态的，它的行为就不具有多态性。静态方法是与类，而非与单个的对象相关联的。

## 构造器和多态

### 构造器的调用顺序

调用构造器要遵照下面的顺序：

1. 调用基类构造器。这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最低层的导出类。
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

### 继承与清理

通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理**（绝大部分情况下并不需要自己手动处理垃圾回收）**。

**如果确实遇到清理的问题，那么必须为新类创建dispose()方法（名称非特定，作用类似即可）。并且由于继承的缘故，如果有其他作为垃圾回收一部分的特殊清理动作，就必须在导出类中覆盖dispose()方法。当覆盖被继承类的dispose()方法时，必须调用基类版本dispose()方法；否则，基类的清理动作就不会发生。**

### 构造器内部的多态方法的行为

**在一般的方法内部，动态绑定的调用是在运行时才决定的**，因为对象无法知道它是属于方法所在的那个类，还是属于那个类的导出类。

**如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。**这个调用的效果可能相当难于预料，因为被覆盖的方法在对象被完全构造之前就会被调用。这可能会造成一些难于发现的隐藏错误。

如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍旧是没有被初始化的。**一个动态绑定的方法调用却会向外深人到继承层次结构内部，它可以调用导出类里的方法。**如果我们是在构造器内部这样做，那么就可能会调用某个方法，而这个方法所操纵的成员可能还未进行初始化。

```java
// PolyConstructors.java
// Constructors and polymorphism
// don't produce what you might expect
class Glyph{
    void draw(){
        System.out.println("Glyph.draw()");
    }
    Glyph(){
        System.out.println("Glyph() before draw()");
        draw();
        System.out.println("Glyph() after draw()");
    }
}
class RoundGlyph extends Glyph{
    RoundGlyph(int r){
        radius = r;
        System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius);
    }   
    private int radius = 1;
    void draw(){
        System.out.println("RoundGlyph.draw(), radius = " + radius);
    }
}
public class PolyConstructors {
    public static void main(String[] args){
        new RoundGlyph(5);
    }
}
/**Output:
 * Glyph() before draw()
 * RoundGlyph.draw(), radius = 0
 * Glyph() after draw()
 * RoundGlyph.RoundGlyph(), radius = 5
 */
```

从结果上看，Glyph构造器对RoundGlyph.draw()调用了，这看起来似乎达到了目的。但是从输出结果上看，Glyph的构造器调用draw()方法时，radius不是默认初始值1，而是0，这与RoundGlyph中定义的radius值并不相符。

**因此，前一节的初始化顺序并不十分完整。初始化的实际过程是：**

1. 在其他任何事物发生之前，将分配给对象的存储空间初始化成二讲制的零。                                                                                   

2. 如前所述那样调用基类构造器 。 此时 ，调用被覆盖后的draw()方法 〈要在调用 RoundGlyph构造器之前调用） ， 由于步骤1的缘故 ， 我们此时会发现radius的值为0。

3. 按照声明的顺序调用成员的初始化方法。
4. 调用导出类的构造器主体

### 编写构造器的有效准则：

***<u>用尽可能简单的方法调用使对象进入正常状态；如果可以的话，避免调用其他方法。</u>***

在构造器内唯一能够安全调用的那些方法时基类中的final方法（也使用于private方法，它们自动属于final方法）。

## 用继承进行设计

当使用现成的类来建立新类时，更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时。

1. 组合不会强制程序设计进入继承的层次结构中。
2. 组合更加灵活，它可以动态选择类型。相反，继承在编译时就需要知道确切类型。

**一条通用的准则**：用继承表达行为间的差异，并用字段表达状态上的变化。

通过继承得到多个不同的类，用于表达某些方法的差异；运用组合使状态发生变化。

### 纯继承与扩展

采取“纯粹”的方式来创建继承层次结构似乎是最好的方式。也就是说，只有在基类中已经建立的方法才可以在导出类中被覆盖。

![1554720267812](D:\GitHub\thinkinginJavanote\images\08-polymorphism02.png)

这被称作是纯粹的“is-a"（是一种）关系，因为一个类的接口已经确定了它应该是什么。

也可以认为这是一种纯替代，因为导出类可以完全代替基类，而在使用它们时，完全不需要知道关于子类的任何额外信息。（即基类可以接受发送给导出类的任何信息）

### 向下转型与运行时类型识别

向上转型（在继承层次中向上移动）会丢失具体的类型信息。通过向下转型（在继承层次中向下移动）能够获取类型信息。

向上转型是安全的，因此基类不会具有大于导出类的接口。

在java语言中，**所有转型都会得到检查**。所以即使我们只是进行一次普通的加括弧形式的类型转换，在进入运行期时仍然会对其进行检查，以便保证它的确是我们希望的那种类型。如果不是，就会返回一个ClassCastException（类转型异常）。这种在运行期间对类型进行检查的行为称作”**运行时类型识别（RTTI）**“。





